### 内存错误

1. 计算机代码是非常死的, 按照规定好的代码来进行处理
2. 早期的编译器比较低效, 慢速


时间线:
1970: C语言诞生, 对内存的直接操作
1980: C++, 面向对象, 但编译语言依旧存在很多危险(compiled language)
1990: 现代的基于虚拟化的语言诞生, 但主流编译语言依旧危险(java)
2000: JIT技术的发展提升了虚拟化和脚本语言的发展, 但编译语言依旧危险
2010: 终于开始探索主流的内存安全编译语言(比如Rust语言, Go语言)

结论:

1. C语言作为一项基础语言, 依旧占有巨大市场, 同时也是许多衍生语言的基础
2. C语言在处理速度上依旧是最快的, 对于许多的小型芯片来说, C语法是高效且节能的
3. C语言对内存的直接操作也导致其存在许多的不安定因素, 对程序员的素质要求非常高
4. 想要获得安全, 就必须牺牲处理速度, 即占用一定的算力去处理自身程序执行的问题, 无法两全

#### stack

在stack中, 所有东西都放在一起, 比如当前func的变量, 指向变量、或者data段数据的指针, 或者指向代码的指针, 当前函数调用所需要的参数等等
这些数据都被放在stack(栈)中, 并被相同的处理

因此, 用户所能控制的输入, 也会可能影响到栈中的数据, 并如果由此导致栈中的函数指针被覆写, 则可能会导致内存的异常访问
或者更进一步的, 控制流劫持


#### 缺陷

1. C语言对字符的处理, 会根据字符串的结尾是否有NULL(\x00)符号来判定
2. C不会对存储区域进行初始化或者回收的clean, 因此如果你的代码没有initial new的区域, 这块区域可能会带有由之前代码遗留下来的未被回收处理的数据


#### 引起缺陷的因素

1. buffer overwrite

由于buffsize通常不会被跟踪, 因此代码中经常会出现overwrite的情况
(用-fno-stack-protector来禁用保护措施)

2. int型与unsigned int, 整形溢出

int 型代表有正负区分, 但unsigned int 型代表无正负区分
在比较大小的时候, 计算机往往需要特定注明, 但程序员可能不一定会注意到
因此有时候输入的负数会被正常看待, 并绕过比较大小的判断, 进入另一个程序流
在另一个程序流中则会由于输入长度的变化(负数实际上是一个非常大的正数), 导致其他不可知问题

特别的, jae是无符号型对比, 而jge是有符号型对比, 这取决于代码和编译器如何选择
要注意, 跳转指令会根据标志位寄存器的值来进行跳转, 因此如果系统未对该值进行回收处理, 则有可能会出现失败的情况

以及, 任何在代码中的+-数学计算, 都会以符号型数据进行计算, 因此,
```c
unsigned int size;
struct my_struct* buffer;
scanf("%i", &size);
buffer = (my_struct*) malloc(size+1);
```
类似这种代码, 都会存在问题。这段代码的问题是通过+1计算可以修改使得buffer申请到0空间的堆指针, 之后如果向buffer的指向结构体操作, 或者赋值, 则会影响到该堆块相邻的东西

3. off-by-one

off-by-one指的是一字节(或者1单位)的溢出导致的异常情况, 这种情况往往发生在程序员编写程序时, 未注意到边界问题导致。如过1字节影响到rbp的末尾值, 则可以在16字节范围内移动rbp的值, 在其他函数调用中产生复杂效果。


4. 内存泄露

对于程序的字符串数组来说, 需要在字符串的末尾加上一个NULL(\x00)标记, 而如果字符串长度与输入的长度一致, 则会导致NULL无法被添加到字符串末尾, 导致当输出该字符串时, 可能会把后续的关联内容一并输出。

注意: canary 的值的末尾两位被设计定为了(\x00), 因此无法被这样泄露出来

未初始化清理过的存储变量也会导致一些内存泄露问题, 它会残留其他函数调用所遗留的一些数据片段。

利用memset函数对申请的空间进行清零是一个好习惯, 但是如果函数中的memset调用在使用之后(即memset后并没有对该指向区域进行使用), 编译器的自动优化可能会导致memset的调用被去除, 这是一种优化的小缺陷, 但往往会被程序员所忽略, 也就是说, 你的代码和最终编译出来运行的代码有可能是不一样的。取决于编译器和编译优化算法。(-O3级别编译优化)

#### 工具

pwndbg  外观插件 https://github.com/jerdna-regeiz/splitmind
需要在tmux终端下使用, 可视化效果很好
dmesg | tail -nl  可以追溯异常触发

### Kernal

内核

#### 简介

内核是系统对所有进程进行管理的终端, 每一个单独的进程可以看作一个独立的州, 内核则是中央政府。

内核会负责对进程的资源分配、管理他们对固件的访问

一些只有内核允许使用的资源:
htl 可以用于停止CPU的计算
in & out 管理固件信息流的进出
一些特殊的寄存器:
cr3(Control Register 3) 用于管理页表, 并用于将虚拟页地址转为物理地址
MSR_LSTAR 定义了syscall函数的跳转地址, 会被wrmsr和rdmsr两个函数调用到


CPU的调用等级分为4个等级, 从ring0到ring3. Ring3 是用户空间, 大部分应用程序都运行在这个级别; Ring1和Ring2并没有被直接定义使用, 而是在其他类似虚拟机、沙箱环境中会被使用, 往往会拥有一部分的调用权限; Ring0则是系统的最高级内核调用, 超级模式, 在这个模式下可以对固件进行直接的操作, 像是定义CPU时钟频率、直接修改硬盘数据等。


伴随着VM(virtual machine)的发展, Ring0变得危险起来。
早期, 使用非常复杂的仿真方法在虚拟机上运行Ring0的行动, 比如模拟一个声音输入输出设备, 并提供类似的接口访问。
在2000年, 强迫VM的内核工作在Ring1级别。
现代, Ring -1(负1), 可以截获所需的Ring0请求并在属主机中进行处理


几种OS内核模型
1. monolithic kernal. 使用唯一、统一的内核二进制文件处理所有OS级别的任务, 驱动作为一个lib模块载入该二进制文件中。Linux, FreeBSD
2. microkenal. 用一个tiny的内核二进制文件(只提供非常基础的功能, 且只有该文件运行在Ring0级别)提供进程交互及与硬件交互, 驱动都是在用户态下具有特定允许的进程。Minux, seL4
3. hybrid kernal(混合). tiny内核伴随着monolithic组件。Windows, MacOS

所以注意, linux的设备驱动本身就是kernal


等级变化(rings switch)

大致总结如下:
1. 开机的时候, 内核将MSR_LSTAR设置指向syscall-handler
2. 当Ring3进程需要与内核交互, 它调用syscall
  系统将当前的等级变为Ring0,
  控制流跳转到MSR_LSTAR指向的处理函数中
  返回地址保存到rcx, 相关寄存器值会保存到堆栈中(运行环境保存)
  # https://www.felixcloutier.com/x86/syscall
3. 当内核处理结束后, 调用sysret返回流程
  当前等级调回Ring3
  控制流跳转回rcx


内核与用户的关系

用户进程位于虚拟地址上, 往往是在低地址区

内核代码则有着它自己存在的虚拟内存空间, 且在高地址区
syscall并不会改变内存映射(memory mapping), 内核代码所在的内存区域只有Ring0级别可以进行访问


#### 总结

内核也是代码, 只是一些运行在特定条件、被保护起来的特殊代码。因此内核本身也会有普通代码所具有的缺陷。不要觉得过于神秘！内核的利用和suid的利用并无区别, 只是内核的利用能够对计算机系统造成更大的威胁(:D)


#### 攻击生命周期

内核的利用可以简单归为以下几种:
1. 通过网络
  大部分的服务器提供的服务, 通过设计巧妙的包, 来实现远程触发(非常少见, 因为大部分服务都运行在用户态, 但是如果是RCE洞加提权倒是会出现)
2. 通过用户态进程
  大多数情况, 问题可能出在syscall和ioctl函数(用于和驱动交互的函数)中
  ps: ioctl(fd, cmd)函数用于与驱动进行交互, 通过对驱动的读写IO流文件fd发送定义好的协议指令, 来对外接设备进行操控。
3. 通过驱动
  通过连接外接设备, 通过驱动来加载内核利用(如USB的U盘驱动加载https://www.pjrc.com/teensy/)

达成结果:
1. 权限提升, 运行rootkits
2. 获得更多的权限去攻击系统的其他部分(用户组提升, 转移到可信执行环境)



### 环境准备
(课程里用到了一个assemble工具, 可以列出不同写法, 像是老师自己写的)
改天再看一遍=。=, 实机操作



### 内核模块

内核模块就是一个库, load进入内核中, 与普通的libc.so不同, 内核模块编译为kernal.ko文件。

内核模块用于以下场景:
1. 驱动
2. 文件系统
3. 网络功能
4. 其他许多的插件

在过去, 内核模块可以通过定义系统调用表来添加额外的系统调用
但是现在不行了

#### 中断

一个模块可以通过调用LIDT和LGDT指令来注册一个中断处理函数, 当你调用到中断时, 比如 int 42, 就会跳到你设定的中断处理函数中。

一些有用的一字节中断指令:
int 3(0xcc) : 硬件中断指令, 返回SIGTRAP, 可以被hook
int 1(0xf1) : 通常用于硬件调试(debug), 可以被hook

模块同样可以hook无效的操作码中断, 可以用于在软件中实现用户定义的指令
一个例子: https://www.youtube.com/watch?v=OhQacawMxoY

#### 文件的哲学

最容易影响到内核模块的方法是通过文件!
比如/dev/底下的所有文件都是和驱动或者系统相关的, 比如dvd, usb啥的
又比如/proc/底下的文件则是和系统进程相关的
/sys/则是内核的非过程(non-process)信息接口

因为linux系统(类unix系统)本身就是一个文件系统, 万物皆文件!!!
因此作为用户态的进程是有可能通过影响这些文件来影响到内核

比如许多摄像头都是通过在进程底下开启一个文件存放视频流, 或者用于处理信号流, 指令流。
流的概念很重要

用户可以通过read, write函数来对这些东西进行操作
或者, 用更高级的, ioctl函数, io-control, ioctl(fd, COMMAND_MODE, &custom_data_structure), 来对驱动、设备、内核进程来进行交互

而如果这些内核进程的处理流程存在问题, 也就是常见的漏洞问题(计算机在内核级处理过程和一般级并无不同, 都是运行在CPU中的软件, 进程)

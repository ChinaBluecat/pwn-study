### 简介

#### 1. 在完整进程中丢失的东西

注释
变量名
函数名
结构体数据
部分算法功能(优化改变了逻辑)

该怎么恢复呢?

#### 2. 工具

VIM
gcc
strings
strip


#### 3. 编译过程

1. gcc -o target.c target # 将目标代码编译为可执行文件
2. cpp target.c # 将完整的目标代码解析出来, 如果代码包括头文件, 则会带上相关信息
3. gcc -S -masm=intel target.c # 编译成中间IR文件, 汇编代码
4. objdump -d target/ objdump -M intel -d target # assemble汇编代码, 可以查看到某些函数名
5. 使用strip + string 可以将编译出的一些函数名消去, 减小可执行文件大小, 并隐藏函数名


#### 4. 一个程序有什么

1. 许多的模块
2. 一些自定义的函数
3. blocks(函数堆块)
4. 指令
5. 变量和结构体等


1. 模块在程序加载的时候会从内存中引入
libary库有很好的文档, 可以查

2. 函数
函数一般会对某些数据进行操作
计算
调用别的函数
进行一些别的行为

---
函数由控制流图组成
控制流图由许多的函数堆块作为节点, 函数执行方向作为边链接组成
通常由jmp, call之类的指令来进行区分

程序开始点统称为elf

3. 什么是堆

本地变量(local variables)则由堆来进行管理
在内存中开辟的一块区域, 叫做堆, 用于放函数内的变量, 以及函数调用上下文
堆从高地址区向低地址区增长

当进行push时, rsp-=8
pop时, rsp+=8

堆涉及的指针有两个 rsp和 rbp
rsp 一直指向堆的顶部
rbp 指向[当前]的堆底

当前意思是, 如果函数进入到了某个子函数调用中, 这时候系统会为该子函数重新分配相应的函数堆空间 rsp-n 并将rbp指向原先rsp的所在位置

完整的操作大致如下:

call func   (push rip指向下一条指令的位置)
|
push rbp
mov rbp, rsp
sub rsp, n

当该函数结束退出时, 系统会回收堆空间
mov rsp, rbp
pop rbp
retn  (之前的rip, 实际上执行的是 pop rip, 把rip指回进入前的位置)


需要注意的是, 系统并不会主动对堆内的数据进行清洗释放, 因为这样很麻烦, 也就是说在某个函数执行结束后, 在堆上的数据依旧是旧的数据。在某些特殊情况下, 如果在一个函数结束后马上调用另一个函数, 而该函数中的参数没进行很好的初始化, 这些参数的值会带有之前那个函数遗留的一些东西, 可能可以利用进行内存泄露

注意的是, rbp, rsp可以被作为一个普通的寄存器进行操作, 因此适当的利用可以获得非常巨大的效果

#### 5. 数据使用

.data 用于初始化的可写全局变量
.rodata 用于全局只读变量
.bss 用于没有初始化的全局可写变量
stack 用于堆, 前一节给出
heap 用于栈, 类似malloc()之类的函数调用, 后面详细讲

.bss, .rodata, .data可以通过对RIP的偏移计算来进行取值
stack的数据可以通过RSP相对位置来取


#### 6. 静态分析

静态分析只针对elf文件进行, 并不能真实反映程序的运行逻辑
许多恶意软件会进行自变异, 代码混淆, 花指令, 反调试暗桩
但是静态分析依旧十分重要


一些工具:
objdump 最基础的二进制-汇编转换工具
nm  查看符号表
checksec 查看保护机制
strings 找二进制文件中是否存在某些字符串, 在什么位置(一般也会用来找自己写的代码)
kaitai struct(https://ide.kaitai.io/): 文件结构标准收录

IDA 自己弄学习版=。=
Binary Ninja (cloud) IDA的商业竞争对手, kali内置可以自己玩玩

开源
angr  一个非常重要的工具, 支持符号执行分析, 有许多论文关于这东西, 会拿一节课讲。学术研究的二进制分析框架
ghidra  开源逆向工具
cutter  开源逆向工具

#### 7. 动态分析

工具
ltrace  追踪库调用
strace  追踪系统调用
gdb     基本调试工具
rr      开源逆向框架
qira    黑客逆向框架


讲了一些gdb的配置如何写, 类似写成插件或脚本

#### 8. 破解机
